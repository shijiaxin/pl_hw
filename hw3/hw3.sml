(* Dan Grossman, CSE341 Spring 2013, HW3 Provided Code *)

exception NoAnswer

datatype pattern = Wildcard
		 | Variable of string
		 | UnitP
		 | ConstP of int
		 | TupleP of pattern list
		 | ConstructorP of string * pattern

datatype valu = Const of int
	      | Unit
	      | Tuple of valu list
	      | Constructor of string * valu

fun g f1 f2 p =
    let 
	val r = g f1 f2 
    in
	case p of
	    Wildcard          => f1 ()
	  | Variable x        => f2 x
	  | TupleP ps         => List.foldl (fn (p,i) => (r p) + i) 0 ps
	  | ConstructorP(_,p) => r p
	  | _                 => 0
    end

(**** for the challenge problem only ****)

datatype typ = Anything
	     | UnitT
	     | IntT
	     | TupleT of typ list
	     | Datatype of string

(**** you can put all your code here ****)

(*  find library here:   http://www.standardml.org/Basis/  *)

fun only_capitals(sl)	=
	List.filter(fn s=>Char.isUpper(String.sub(s,0)))(sl);

(* foldl (+) 0 [1..5] = 15 *)
(* foldl (fn (x,y)=> x+2*y) 0 [1,2,3] = 2*(2*(2*0+1)+2)+3 = 11 *)

fun longest_string1(sl)   =
	let
		fun get_longer(s1,s2)=
			if(String.size(s1) > String.size(s2))
				then s1
			else s2 
	in
		foldl get_longer "" sl
	end ;
fun longest_string2(sl)   =
	let
		fun get_longer(s1,s2)=
			if(String.size(s1) >= String.size(s2))
				then s1
			else s2 
	in
		foldl get_longer "" sl
	end ;
fun longest_string_helper f sl =
	let
		fun get_longer(s1,s2)= 
			if(f(String.size(s1),String.size(s2)))
				then s1
			else s2 
	in
		foldl get_longer "" sl
	end ;
val longest_string3 = longest_string_helper (Int.>);
val longest_string4 = longest_string_helper (Int.>=);

val longest_capitalized = longest_string1 o only_capitals ;
val rev_string=String.implode o rev o String.explode ;

fun first_answer f lst=
	case lst of
		[]		=>	raise NoAnswer
	|	x::xs	=>	case f(x) of
						NONE 	=> first_answer f xs
					|	SOME v 	=> v ;

fun all_answers f lst =
	case lst of
		[]		=> 	SOME []
	|	x::xs 	=> 	case all_answers f xs of
						NONE 		=>	NONE
					|	SOME res 	=>	case f(x) of
											NONE 		=>NONE
										|	SOME res_x 	=>SOME (res_x @ res);




(* 9 *)
(* f1 is used to count something about Wildcard , 
and f2 is used to count something about Variable
and g will add all the result generated by f1 and f2 recursively
*)

val count_wildcards = g (fn {}=>1) (fn x:string =>0) ;
val count_wild_and_variable_lengths = g (fn {}=>1) String.size ;

fun count_some_var(s,p)=
	g (fn {}=>0) (fn x => if(x=s) then 1 else 0 ) p;

fun check_pat(p)=
	let
		fun append_val(p) =
			case p of
				Variable x 			=> [x]
			|	TupleP ps 			=> List.foldl (fn (pa,l) => (append_val pa) @ l) [] ps
			|	ConstructorP(_,pa) 	=> append_val pa
			|	_					=> [] 
		fun is_repeats(lst)=
			case lst of
				[]		=>false
			|	x::xs	=> (is_repeats(xs)) orelse (List.exists (fn t=> x=t) (xs))
	in
		not (is_repeats(append_val(p)))
	end ;

fun match (v,p)=
	case (v,p) of 
		(_,Wildcard)		=>	SOME []
	|	(_,Variable s) 		=>	SOME [(s,v)]
	|	(_,UnitP)  			=>	SOME []
	|	(Const i1,ConstP i2)=>  if(i1=i2)then SOME [] else NONE
	|	(Constructor(s1,v1),ConstructorP(s2,p2)) 	=> if(s1 = s2) then match(v1,p2)
														else NONE
	|	(Tuple vl,TupleP pl)=>	(	(let
									val pairl=ListPair.zipEq(vl,pl) 
								in
									all_answers (fn  (v0,p0)=>match (v0,p0)) pairl 
								end ) handle UnequalLengths => NONE )
	|	(_,_)				=>	NONE ;

fun first_match v pl=
	(let val lst=first_answer (fn p=>match(v,p)) pl 
	in SOME lst
	end ) handle NoAnswer => NONE ;

fun merge_type(tp1,tp2)=
	if tp1 = tp2 
	then tp1
	else case (tp1,tp2) of
			(_,Anything) => tp1
		|	(Anything,_) => tp2
		|	(TupleT tpl1, TupleT tpl2) =>
				if List.length tpl1 = List.length tpl2
				then TupleT( List.map merge_type (ListPair.zip(tpl1,tpl2)) )
				else raise NoAnswer
		|	(_, _) => raise NoAnswer ;

(* pattern2type(lst, p0) = pp orelse pattern2type(lst, p0) = Anything  *)

fun pattern2type (lst, p) =
	case p of
		UnitP 		=>	UnitT
	|	ConstP i 	=>	IntT
	|	TupleP pl 	=>	TupleT(List.map (fn x=>pattern2type(lst,x)) pl)
	|	ConstructorP(s0, p0) =>
        let fun cons_match x =
                case x of
                    (s, _, pp) => s = s0
                                  andalso merge_type(pattern2type(lst,p0),pp)=pp
        in case List.find cons_match lst of
               SOME (_, a, _) => Datatype a
             | NONE => raise NoAnswer
        end
	|	_			=>  Anything ;


fun typecheck_patterns (lst, ps) =
    let 
    	val tpl = List.map (fn x => pattern2type(lst, x)) ps
                   handle NoAnswer => []
    in
        case tpl of
            [] => NONE
		|	x::xs => SOME (List.foldl merge_type x xs)
                          handle NoAnswer => NONE
    end ;
















